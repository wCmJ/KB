server:
    - 连接器
        - 建立连接
            - show processlist;查询建立的连接
            - 建立tcp连接
            - 验证账号密码，不通过则断开连接
            - 连接的资源在断开时才释放，如果长时间累计，可能导致内存使用太大，OOM，从现行看就是MySQL异常重启了
                - 定时断开连接
                - mysql_reset_connection重新初始化连接，这个过程不做重连和权限验证，会将连接恢复到刚建立时的状态
        - 权限表获取权限（后续使用权限均来自此次获取的信息，只有新连接才能使用新权限）
        - 查询缓存
            - 失效频繁，对一个表进行修改，整个表的缓存被清空

    - 分析器
        - 对SQL语句做解析，分析要做什么
            - 词法分析
            - 语法分析
                - 如果错误，"You have an error in your SQL syntax"
    - 优化器
        - 经过分析器之后，MySQL知道要做的事情，在执行之前，还需经过优化器的处理
        - 在表中有多个索引的时候，决定使用哪个索引；在一个语句有多表关联的时候，决定各个表的连接顺序
        - 优化器阶段完成后，这个语句的执行方案就定下来了
    - 执行器
        - 判断对表有没有查询权限，如果命中查询缓存，会在缓存结果返回的时候，做权限验证
        - 

    - show variables;
    - set global slow_query_log=ON
    - set global slow_launch_time=5

    - 搜索一个不存在的列，错误信息是在哪个阶段报出来的？
        - 分析器。在分析阶段会判断语句是否正确，表是否存在，列是否存在。

一条查询语句执行流程：
    - 连接器 -> 分析器 -> 优化器 -> 执行器

一条更新语句也需要走一遍查询语句的流程，除此之外，更新流程还涉及两个重要的模块：redo log(重做日志)和binlog(归档日志)

MySQL整体有两块：
    - Server层
        - 负责MySQL功能层面的事情
        - server层有自己的日志，称为binlog（归档日志）

    - 引擎层
        - 负责存储相关事宜
        - MySQL自带的引擎MyISAM没有crash-safe能力
        - redo log是InnoDB引擎特有的日志（重做日志）
        - InnoDB以插件形式被引入MySQL

- redo log
    - WAL技术：Write-Ahead Logging，关键点是先写日志，再写磁盘
    - InnoDB引擎特有的日志，log是固定大小的，从头开始循环写
    - 将操作记录在redo log中，这是一个循环列表，有两个标记：write pos和checkpoint。
    - write pos表示当前写入的位置
    - checkpoint表示擦除的位置
    - 当write pos和checkpoint相遇的时候，表示没有空间可以写入，需要进行擦除。在擦除之前，要将操作写入磁盘中。
    - 有了redo log，即使数据库发生异常重启，之前提交的记录都不会丢。称为crash-safe能力。

- binlog
    - 是server层提供的，所有引擎都可以使用
    - 


对比
    - redo log是InnoDB引擎独有，binlog是MySQL的server层实现，所有引擎都可以使用
    - redo log是物理日志，记录的是”在某个页面做了什么修改“，binlog是逻辑日志，记录的是这个语句的原始逻辑，比如”给ID=2这一行的c字段加1“
    - redo log是循环写的，空间固定会用完。binlog是追加写的，追加写是指binlog文件写到一定大小后会切换到下一个，并不会覆盖前面的


update语句执行流程
    - 执行器 找 引擎 取ID=2这一行，引擎 用树搜索找到这一行。如果这一行所在的 数据页 在内存中，就直接返回给执行器，否则，需要先从磁盘读入内存，然后再返回
    - 执行器 拿到 引擎 给的行数据，把这个值加1，得到新的一行数据，再调用引擎接口写入这行新数据
    - 引擎 将这行数据更新到内存，同时将这个更新操作记录到 redo log 中，此时 redo log 处于 prepare 状态，然后告知 执行器 执行完成了，随时可以提交事务
    - 执行器 生成这个操作的binlog，并把binlog写入磁盘
    - 执行器 调用 引擎 的提交事务接口，引擎把刚刚写入redo log改成提交状态，更新完成


事务
    - 体现的是原子性
    - 事务都是在引擎层实现的，并不是所有引擎都支持事务
    - ACID：原子性、一致性、隔离性、持久性
        - 多个事务同时执行的时候，就可能出现脏读、不可重复读、幻读，为了解决这些问题，就有了隔离级别的概念
        - 隔离级别越高，效率就越低，隔离级别包括
            - 读未提交：一个事务还没提交时，它做的变更能被别的事务看到
            - 读提交：一个事务提交之后，它做的变更才能被其他事务看到
            - 可重复读：一个事务在执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。未提交变更对其他事务也是不可见的
            - 串行化：对同一行记录，写会加写锁，读会加读锁。当出现读写冲突时，后访问的事务必须等到前一个事务完成，才能继续执行
        - 在实现上，数据库会创建一个视图，访问的时候以视图的逻辑结果为准。
            - 可重复读隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图
            - 读提交隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的。
            - 读未提交隔离级别下直接返回记录上的最新值，没有视图概念
            - 串行化直接用枷锁的方式来避免并行访问 

        - MySQL默认隔离级别是读提交
        
        - 每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，都可以得到前一个状态的值
        - 同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）
        - 回滚日志在不需要的时候被删除。系统会判断，当没有事务需要用到这些回滚日志时，回滚日志会被删除
        - 什么时候不需要？当系统里没有比这个回滚日志更早的read-view的时候
        - 尽量不要使用长事务，长事务意味着系统里面会存在很老的事务视图        

    - 启动
        - 显式启动事务：begin | start transaction，配套的提交语句是commit，回滚语句是rollback
        - set autocommit = 0，将线程的自动提交关闭。意味着如果只执行一个select语句，这个事务就启动了，而且并不会自动提交，这个事务持续存在直到你主动执行commit或rollback或断开连接
        - 有些客户端连接框架会默认连接成功后先执行一个set autocommit = 0命令

索引
    - 索引的出现就是为了提高数据查询的效率
    - 索引就是数据库的目录
    
    - 哈希表适用于只有等值查询的场景：比如Memcached | NoSQL

    - 有序数组在等值查询和范围查询场景中的性能都非常优秀，更新复杂，只适用于静态存储引擎，即数据不再修改

    - N叉树

    - 数据库底层存储的核心就是基于这些数据模型的
    - 在InnoDB中，表都是根据主键顺序以索引的形式存放。每一个索引在InnoDB里面对应一颗B+树
    - 根据叶子节点的内容，索引类型分为主键索引和非主键索引
    - 主键索引的叶子节点存的是整行数据，在InnoDB中，主键索引也被称为聚簇索引
    - 非主键索引的叶子节点内容是主键的值，在InnoDB中，非主键索引个也被称为二级索引
    - 基于非主键索引的查询需要多扫描一颗索引树。

    - 重建索引k:
        - alter table T drop index k;
        - alter table T add index(k);
        - 合理，可以达到节省空间的目的。因为删除和页分裂等原因，导致数据页有空洞，重建索引的过程会创建一个新的索引，把数据按顺序插入，页面的利用率最高，索引更紧凑，更省空间

    - 重建主键索引：
        - alter table T drop primary key;
        - alter table T add primary key(id);
        - 不合理。不论是删除主键还是创建主键，都会将整个表重建。

    - 考虑能不能不回表
        - 覆盖索引
            - 当前索引能覆盖我们的查询需求，称为覆盖索引
            - 覆盖索引可以减少树的搜索次数，显著提升查询性能，覆盖索引是一个常用的性能优化手段


    - 最左前缀原则
        - 只要满足最左前缀，就可以利用索引来加速检索，这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符
        - 评估标准：索引的复用能力
        - 联合索引(a,b)：当查询条件里面只有b的语句时，是无法使用(a,b)这个联合索引的


    - 索引下推
        - 在MySQL5.6引入的索引下推优化，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤不满足条件的记录，减少回表次数
    
总结
    - 尽量少地访问资源是数据库设计的重要原则之一，设计数据库时，也要以减少资源消耗为目标
    - 用alter table T engine=InnoDB，替代主键删除







