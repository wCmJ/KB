* 零拷贝是指减少用户态和内核态的切换次数以及CPU拷贝的次数

* 用于通过网络传输文件时节省CPU周期和内存带宽

* 实现方式
    - mmap + write
        - 使用mmap替换read+write中的read操作，减少了一次CPU的拷贝

        - 实现方式是将读缓冲区的地址和用户缓冲区的地址进行映射，内核缓冲区和应用缓冲区共享，减少了从读缓冲区和用户缓冲区的一次CPU拷贝

        - 用户进程中的内存是虚拟的，只是映射到内核的读缓冲区，可以节省一半的内存空间，比较适合大文件的传输

    - sendfile
        - 相比mmap来说，sendfile同样减少了一次CPU拷贝，还减少了2次上下文切换

        - sendfile是Linux2.1内核引入的一个系统调用函数

        - sendfile调用一次，即可把磁盘中的数据拷贝至网卡，避免了用户空间和内核空间的拷贝

        - sendfile方法IO数据对用户空间完全不可见，只能适用于完全不需要用户空间处理的情况，比如静态文件服务器

    - sendfile + DMA Scatter/Gather
        - Linux2.4内核版本之后，对sendfile做了进一步优化，通过引入新的硬件支持，这个方式叫做DMA Scatter/Gather 分散/收集功能

        - 它将读缓冲区的数据描述信息- 内存地址和偏移量记录到socket缓冲区，由DMA根据这些信息将数据从读缓冲区拷贝到网卡，减少了一次CPU拷贝

零拷贝应用场景
    - 对于MQ而言，生产者发送数据到MQ然后持久化到磁盘，之后消费者从MQ读取数据

    - 对于RocketMQ而言，两个步骤使用的是mmap+write

    - Kafka则是使用mmap+write持久化数据，发送数据使用sendfile

总结
    - 由于CPU和IO速度的差异问题，产生了DMA技术，通过DMA搬运来减少CPU的等待时间

    - 传统的IO read+write方式会产生2次DMA拷贝+2次CPU拷贝，同时有4次上下文切换

    - mmap+write方式则产生2次DMA拷贝+1次CPU拷贝，4次上下文切换，通过内存映射减少了一次CPU拷贝，可以减少内存使用，适合大文件传输

    - sendfile方式是新增的一个系统调用函数，产生2次DMA拷贝+1次CPU拷贝，只有2次上下文切换，减少了上下文切换，但是用户控件对IO数据不可见，适用于静态文件服务器

    - sendfile+DMA Scatter/Gather方式产生2次DMA拷贝，没有CPU拷贝，只有2次上下文切换，虽然极大提升性能，但是需要依赖新的硬件设备支持

* 虚拟地址的空间和指令集的地址长度有关，不一定和物理地址长度一致。

* 物理空间的大小和地址总线的长度相关

