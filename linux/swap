在内存基础篇我们已经学过，这其实会导致两种可能结果，内存回收和 OOM 杀死进程。

内存回收，也就是系统释放掉可以回收的内存，比如我前面讲过的缓存和缓冲区，就属于可回收内存。它们在内存管理中，通常被叫做文件页（File-backed Page）。

大部分文件页，都可以直接回收，以后有需要时，再从磁盘重新读取就可以了。
而那些被应用程序修改过，并且暂时还没写入磁盘的数据（也就是脏页），就得先写入磁盘，然后才能进行内存释放。
这些脏页，一般可以通过两种方式写入磁盘。
    可以在应用程序中，通过系统调用 fsync ，把脏页同步到磁盘中；
    也可以交给系统，由内核线程 pdflush 负责这些脏页的刷新

- 缓存
- 缓冲区
- 内存映射的文件映射页
- 堆内存

swap：
    - 把不常用的内存先写到磁盘中，然后释放内存供其他进程使用。待重新使用时，再从磁盘读入。
    - 换入
        - 进程的内存数据 -> 磁盘，释放该内存
    - 换出
        - 进程再次访问，从磁盘读入

    - 系统休眠和快速开机功能，也是基于swap
        - 休眠：把系统内存存入磁盘
        - 开机：从磁盘加载内存

内存紧张 -> swap
    - 如何衡量内存紧张？
    - 新的大块内存分配请求，系统内存不足。系统执行直接内存回收。
    - 定期回收内核线程：看kswapd0.
        - 分为三个档位，最小、低、高
        - 最小：/proc/sys/vm/min_free_kbytes
        - 低： 最小*5/4
        - 高： 最小*3/2 

创建swap文件
    - fallocate /mnt/swapfile
设置权限
    - chmod 600 /mnt/swapfile
配置swap文件
    - mkswap /mnt/swapfile
开启swap
    - swapon /mnt/swapfile



