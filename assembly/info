地址总线 + 控制总线 + 数据总线
    - 地址总线的根数决定了寻址范围
    - 控制总线的根数决定了控制范围
    - 数据总线的根数决定了一次传输数据的大小

RAM + ROM
    - RAM：随机存储器
    - ROM：只读存储器
    - BIOS ROM
    - 显存：显卡上的RAM
    - 显卡上的ROM存储显卡的BIOS


AX，BX，CX，DX
    - 存储一般性的数据，又称通用寄存器
    - 均为16-bit
    - 为了兼容以前8-bit版本，又可以分为两个独立的部分：
        - AH + AL
        - BH + BL
        - CH + CL
        - DH + DL
    - 当发生溢出时，寄存器会丢弃溢出位，由CPU做另外的处理

段地址 + 偏移地址： 8086CPU为16-bit，地址总线为20-bit
    - 均为16-bit
    - 段地址左移四位 + 偏移地址，可以达到20-bit的寻址范围
    - 段地址必须是16的倍数
    - 偏移地址为16-bit，寻址范围为64KB

段寄存器
    - 8086CPU不支持将数据直接送入段寄存器的操作，硬件设计问题

    - CS, DS, SS, ES
    - CS & IP
        - CS：代码段寄存器
        - IP：指令指针寄存器
        - 执行流程：
            - 地址加法器：CS + IP获得物理地址
            - 输入输出电路：地址加法器将物理地址送入输入输出控制电路
            - 地址总线：输入输出电路将物理地址送上地址总线
            - 数据总线：物理地址存放的机器指令通过数据总线被送入CPU(输入输出电路)
            - 指令缓冲器：输入输出电路将机器指令送入指令缓冲器
            - IP值自动增加
            - 执行器：执行机器指令
        - 简要描述：
            - 从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器
            - IP增加读取指令的长度，从而指向下一条指令
            - 执行指令，转到开始，重复这个过程

    - 改变CS & IP可以用来控制CPU执行
    - mov：
        - mov指令不能用来修改CS, IP的值，8086CPU没有提供这样的功能
        - 将数据直接送入寄存器
        - 将一个寄存器的内容送入另一个寄存器
        - 将一个内存单元中的内容送入一个寄存器中

        - mov 寄存器<->寄存器
        - mov 寄存器<->内存单元
        - mov 寄存器<->段寄存器
        - mov 段寄存器<->内存单元

    - jmp：jmp指令可以修改CS，IP
        - 修改CS和IP的值：jmp 段地址：偏移地址
            - jmp 3:0B16 CS=0003H, IP=0B16H
        - 仅修改IP的值：jmp 某一合法寄存器
            - jmp ax 执行前 ax=1000H, CS=2000H, IP=0003H; 执行后 ax=1000H, CS=2000H, IP=1000H
            - jmp ax 从功能上来说：mov IP, ax

    - DS
        - DS用来存放要访问数据的段地址
            - mov bx, 1000H
            - mov ds, bx
            - mov al, [0]


    - 栈
        - 8086CPU入栈和出栈操作都是以字为单位进行的
        - PUSH ax 将ax中的数据入栈
        - POP ax 取出栈顶数据放入ax中
        - SS & SP
            - SS:SP指向栈顶元素
        - CPU不会检测栈顶越界问题，它只考虑当前的情况：当前栈顶在何处，要执行的指令是那一条

    - loop
        - loop会计算cx的值，如果为零，则执行下一条；如果不为0，则执行loop指定的代码

    - 段前缀
        - mov ax, cs:[bx]

